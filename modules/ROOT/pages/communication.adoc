= Basics of communication
:imagesdir: _images/

== General communication convention

Communication with the agrirouter includes communication with inbox AND outbox, regardless whether an app only sends messages or only consumes messages. Every message or command is sent to the inbox, results are always delivered through the outbox.

== Prerequisites for communication

Every communication is initiated by the App Instance. The agrirouter endpoint will never contact the app instance.

After application registration, the communication is secured using the SSL certificate retrieved during the onboarding process. The agrirouter provides PKCS12 certificates as well as PEM certificates which can be set within the SSL context of the request to ensure authenticated communication with the agrirouter.

After the validation has happened, the agrirouter provides all necessary security information to establish a messaging connection. The developer is obliged to store this certificate or the tokens secured and encrypted within the application. 
Receiving the certificate is described in xref:integration/onboarding.adoc[onboarding] .

== Different layers, the "onion principle”

agrirouter is a platform that is mostly used to transport messages *through* it and not towards it.

Therefore:

* the content is encapsulated in

** messages and commands, which are encapsulated into

*** the request to and the result from the agrirouter, which are encapsulated into

**** the protocol layer of REST using Request and Response or MQTT using Publish and Subscribe.

With exception of EFDI telemetry messages (DeviceDescription and live data), agrirouter doesn’t analyse the messages inside the agrirouter request. It just checks the technical message type and the addressing to determine the recipients based on the routings and subscriptions.

.The onion principle for a non-telemetry message
image::ig2/image31.png[The onion principle for a non-telemetry message,543,313]


An exception are the EFDI telemetry messages.

The device descriptions are needed by the agrirouter to

* determine the relevant CU when sending a message directly to a machine
* filter for DDIs that are allowed to be sent to specific endpoints
* be sent to endpoints that subscribe to telemetry data after the device description was already sent

The live telemetry data is analysed so that filtering for value categories like fuel consumption is possible.

.The onion principle for a telemetry message
image::ig2/image32.png[The onion principle for a telemetry message,644,371]



[NOTE]
====
Even if a client uses native protobuf for communication instead of JSON, a command has to be put into a payload wrapper that mentions the message/command type.
====
== The protocol layer

The protocol layer describes the basic communication layer. All agrirouter communication is based on a TCP-IP communication.
 When onboarding an endpoint, the developer can choose between REST and MQTT.

=== REST

REST is a well-known principle for online APIs. For more information on REST, please see following resources:

* link:https://en.wikipedia.org/wiki/Representational_state_transfer[]
* link:+https://code.tutsplus.com/tutorials/a-beginners-guide-to-http-and-rest--net-16340+[]

REST uses HTTP requests that results in an HTTP Response.

[NOTE]
====
REST is based on single, request only methods, therefore, the agrirouter cannot contact any endpoint. This means that the endpoint for example has to poll for new messages in the outbox.
====

==== Communication Workflow with the Inbox

Using REST, an app instance just receives an HTTP 200 "OK” Response. The App Instance sends a HTTP Post request over an SSL secured connection.

.Request and Response in HTTP
image::ig2/image33.png[Request and Response in HTTP,631,212]


==== Communication with the Outbox

Using REST, the communication with the Outbox requires polling:

.REST Communication with the outbox
image::ig2/image34.png[REST Communication with the outbox,613,145]

Make sure to meet the xref:./messaging-workflow.adoc#request-sending-frequency[request frequency requirements].

=== MQTT

MQTT is a subscription based protocol. Therefore, the client can be informed by agrirouter that new messages are available. For further information, please refer to the following recource:

* https://mqtt.org/

The agrirouter provides an MQTT Broker serverside, so, an app instance has to connect to this server with its client.

The agrirouter provides one MQTT Server per Endpoint, so there is no danger or chance to subscribe for messages of another endpoint.

==== General setup

An MQTT connection requires 2 types of certificates. On the one hand, there is a MQTT Server Certificate, for which you can find the keys xref:./keys.adoc#MQTT-communication[here].

This is required to setup an MQTT Connection over SSL.

Additionally, TLS needs to be activated and the TLS certificate can either be the certificate received during xref:./integration/onboarding.adoc[onboarding] or from the xref:./router-devices.adoc[Router Devices].

==== Communication with the Inbox

Using MQTT, the app instance will publish the request and after a while, the agrirouter will publish the response. Polling is not required.

.Request and Response using MQTT
image::ig2/image35.png[Request and Response using MQTT,618,153]


==== Communication with the Outbox

.Receiving Result from the outbox in MQTT
image::ig2/image36.png[Receiving Result from the outbox in MQTT,633,151]


If there are messages available in the outbox, agrirouter will simply publish them to the MQTT App Instance.


[IMPORTANT]
====
This only applies to command results, not to messages that are sent to the feed by another app instance. 
Those messages still have to be requested through the inbox but are automatically delivered through the outbox afterwards.

**Exception**: If xref:./integration/push-notification.adoc[Push Notifications] are activated, the messages are delivered without a special feed request.
====


==== Router Devices
When using MQTT for a telemetry platform or a farming software with multiple accounts, multiple MQTT connections to different brokers would be required. To avoid this, agrirouter introduced **router devices** which allow to use just one connection for multiple, virtual endpoints.

===== General function
Without router devices, an application would need to create multiple MQTT connections, which might cost quite a lot of resources. Therefore, router devices were implemented to allow routing multiple connections using one single MQTT broker.


.Using router devices vs. not using router devices
image::general/router-devices1.png[Using router devices vs. not using router devices]

.Using router devices vs. communication using communication units
image::general/router-devices2.png[Using router devices vs. communication using communication units]

====== Setup of router devices
Router devices can be set up and managed within the agrirouter developer UI
.Router device management in the agrirouter developer UI
image::general/router-devices-screen1.png[Router device management in the agrirouter developer UI]

The setup and usage of router devices is described in the chapter xref:./router-devices.adoc[router devices].

=== Comparison of protocols

Both protocols have several advantages and disadvantages. To select the right protocol for your needs, check the following table

[cols="4,2,2",options="header",]
|=============================================
|Topic |MQTT |REST
|Can be used for onboarding | |X
|Can send JSON |X |X
|Can send raw protobuf | |X
|Needs no polling |X |
|Steps for Call and Result |3 |min. 4; polling
|=============================================

== Advise on protocol choice

Every app provider is free to select his preferred format from the list above.

DKE however advises to use MQTT using RouterDevices for any application that handles multiple endpoints (e.g. Telemetry Platforms, but also Farming Software that is a cloud software and communicates on behalf of multiple accounts) or sends data at a frequency higher than 1 message per minute. 


== Abstraction of communication workflows

To avoid graphs with too many arrows, we simplify the upcoming requests, abstracting MQTT and REST. Whatever protocol you use, a request and response in this document will look like this:

==== Abstraction of Calls to the Inbox

.Abstraction of a Call or Message Sending to the Inbox
image::ig2/image37.png[Abstraction of a Call or Message Sending to the Inbox,637,99]


==== Abstraction of Results from Outbox

.Abstraction of a result from the outbox
image::ig2/image38.png[Abstraction of a result from the outbox,628,87]


= Communication of App Instance and Endpoint

== Endpoint Adresses

The endpoint addresses of the inbox and outbox are delivered with the onboarding request. Please refer to xref:./integration/onboarding.adoc[Send onboarding Request].


== Assigning a result to a request

The assignment between messages sent to the inbox and their corresponding messages in the outbox is done by comparing the application_message_id provided by the app. Therefore, this application_message_id **should be unique**.


[CAUTION]
====
*EXCEPTION*:

If a message is not correctly encoded, so that the agrirouter cannot decode it, there will be no application_message_id in the result.
====

== Flow for sending messages

Sending messages to the agrirouter creates an ACK message in the outbox of the agrirouter

.Send Message or Command to agrirouter
image::ig2/image39.png[Send Message or Command to agrirouter,512,210]


== Flow of commands

.Command Flow
image::ig2/image40.png[Command Flow,482,290]


== Flow of requesting messages from the feed

If the command is a feed command requesting messages from the feed, the app instance has to confirm the receival of the message, so that it is deleted from the feed.

.Command flow for reading the feed
image::ig2/image41.png[Command flow for reading the feed,575,348]

[IMPORTANT]
====
The first message to a new endpoint **always** has to be the xref:./commands/endpoint.adoc[Capabilities Message]!
====


== Flow of push notifications
When activated, agrirouter will deliver messages directly as push notifications. 


.Command flow for push Notifications
image::general/message-push-flow.png[Command flow for push Notifications,575,300]

For further information, see xref:./integration/push-notification.adoc[ the chapter about push notifications].



== Terms

A command-process consists of a call (1.1) to the inbox. This call consists of the request and a processing status response. agrirouter will return a result through the outbox. If a message list was delivered from the feed, the messages have to be confirmed.
